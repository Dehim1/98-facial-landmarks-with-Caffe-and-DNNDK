/*
-- (c) Copyright 2018 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and

-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
*/
#ifndef __DENSEBOX_H__
#define __DENSEBOX_H__

#include <chrono>
#include <map>
#include <memory>
#include <opencv2/core.hpp>
#include <tuple>
#include <utility>
#include <vector>

#include <dnndk.h>

using namespace std;
using namespace std::chrono;
using namespace cv;

#ifdef _PERFORMANCE
#define _T(func)                                                          \
  {                                                                       \
    auto _start = system_clock::now();                                    \
    func;                                                                 \
    auto _end = system_clock::now();                                      \
    auto duration = (duration_cast<microseconds>(_end - _start)).count(); \
    string tmp = #func;                                                   \
    tmp = tmp.substr(0, tmp.find('('));                                   \
    cout << "[TimeMeasure]" << left << setw(30) << tmp;                   \
    cout << right << setw(10) << duration << " us" << endl;               \
  }
#else
#define _T(func) func;
#endif

#ifdef _DEBUG
#define __TRACE__ \
  { cout << "[TRACE]" << __FILE__ << " : " << __LINE__ << " " << __FUNCTION__ << endl; }
#else
#define __TRACE__
#endif

namespace deephi {

/*
 * class DenseBox: face detection using densebox model
 */
class DenseBox {
 public:
  DenseBox() { __TRACE__ }
  ~DenseBox() { __TRACE__ }

  /*
   * @brief Init - initialize densebox model
   *
   * @param kernel_name - the kernel name which is generated by DNNC
   * @param input_node - name of the input node in densebox model
   * @param output_node - name of the output node in densebox model
   * @param conv_node - name of the input node in densebox model
   * @param image_scale - the scale of image
   * @param th_conf - confidence threshold
   * @param th_iou - the IOU threshold
   * @param tile_dim - the tiling dimension
   */
  void Init(const string &kernel_name = "densebox_0", const string &input_node = "L0",
            const string &output_node = "bb_output", const string &conv_node = "pixel_conv",
            float image_scale = 0.02, float th_conf = 0.65, float th_iou = 0.3, int tile_dim = 8);

  /*
   * @brief Run - face detection using densebox model
   *
   * @param task - pointer to DPUTask
   * @param img - the input image
   *
   * @note the detected face boxes will be directly put on the original input image.
   */
  void Run(DPUTask *task, const Mat &img, vector<array<float, 5>>* result);

  /*
   * @brief PostProcess - post process of face detection
   *
   * @param task - pointer to DPUTask
   * @param img - the input image
   *
   * @note the detected face boxes will be directly put on the original input image.
   */
  void PostProcess(DPUTask *task, const Mat &img, vector<array<float, 5>>* result);

  /*
   * @brief - release resource
   */
  void Finalize();

  /*
   * @brief - insert the task pointer
   */
  void InsertTask(DPUTask *task) { tasks.emplace_back(task); }

 private:
  /*
   * @brief tiling - Reorder the conv layer's output to a sequence
   *
   * @param input   - the input data's address
   * @param output  - the output data vector
   * @param channel - the channel
   * @param height  - conv-layer's height
   * @param width   - conv-layer's width
   * @param tileDim - tiling dimension
   * @param scale   - the scale of conv-layer to float, default is 1.0
   */
  void tiling(const int8_t *input, vector<vector<float>> &output, int channel, int height,
              int width, int tileDim, float scale = 1.0);

  /*
   * @brief softmax - Calculate softmax on CPU
   *
   * @param input   - vector of input data
   * @param output  - output vecotr
   */
  inline void softmax(vector<vector<float>> &input, vector<vector<float>> &output);

  /*
   * @brief getOriginalFaceBoxes - Get Original Faceboxes
   *
   * @param outTensor - output Tensor
   * @param tileH - tile height
   * @param tileW - tile width
   * @param tileDim - tile dimension
   * @param pred - prediction vector
   * @param boxes - output facebox vector
   */
  void getOriginalFaceBoxes(DPUTensor *outTensor, int tileH, int tileW, int tileDim,
                            vector<vector<float>> &pred, vector<array<float, 5>> &boxes);

  /*
   * @brief NMS - Discard overlapping boxes using NMS
   *
   * @param box - input box vector
   * @param result - output box vector after discarding overlapping boxes
   * @param threshold - IOU threshold
   */
  template <typename T>
  void NMS(const vector<array<T, 5>>& box, vector<array<T, 5>>*result, float threshold);


 public:
  DPUKernel *kernel;  // pointer to DPU kernel of this model
 private:
  string kernel_name_;
  string input_node_;
  string output_node_;
  string conv_node_;
  float image_scale_;
  float th_conf_;
  float th_iou_;
  int tile_dim_;

  vector<DPUTask *> tasks;
};

}  // namespace deephi

#endif
