/*
-- (c) Copyright 2018 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and

-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
*/
#include "densebox.h"

namespace deephi {

/*
 * @brief Init - initialize densebox model
 *
 * @param kernel_name - the kernel name which is generated by DNNC
 * @param input_node - name of the input node in densebox model
 * @param output_node - name of the output node in densebox model
 * @param conv_node - name of the input node in densebox model
 * @param image_scale - the scale of image
 * @param th_conf - confidence threshold
 * @param th_iou - the IOU threshold
 * @param tile_dim - the tiling dimension
 */
void DenseBox::Init(const string &kernel_name, const string &input_node, const string &output_node,
                    const string &conv_node, float image_scale, float th_conf, float th_iou,
                    int tile_dim) {
  kernel_name_ = kernel_name;
  input_node_ = input_node;
  output_node_ = output_node;
  conv_node_ = conv_node;
  image_scale_ = image_scale;
  th_conf_ = th_conf;
  th_iou_ = th_iou;
  tile_dim_ = tile_dim;

  __TRACE__

  // Load DPU Kernel for DenseBox neural network
  kernel = dpuLoadKernel(kernel_name_.c_str());
}

/*
 * @brief tiling - Reorder the conv layer's output to a sequence
 *
 * @param input   - the input data's address
 * @param output  - the output data vector
 * @param channel - the channel
 * @param height  - conv-layer's height
 * @param width   - conv-layer's width
 * @param tileDim - tiling dimension
 * @param scale   - the scale of conv-layer to float, default is 1.0
 */
void DenseBox::tiling(const int8_t *input, vector<vector<float>> &output, int channel, int height,
                      int width, int tileDim, float scale) {
  int output_width = width * tileDim;
  int length = tileDim * tileDim * channel;
  for (int c = 0; c < channel; ++c) {
    for (int h = 0, oy = 0; h < height; ++h, oy += tileDim) {
      for (int w = 0, ox = 0; w < width; ++w, ox += tileDim) {
        for (int ty = 0; ty < tileDim; ++ty) {
          for (int tx = 0; tx < tileDim; ++tx) {
            int col = (oy + ty) * output_width + ox + tx;
            int idx = (ty * tileDim + tx) + (c * tileDim * tileDim) + (h * width + w) * length;
            output[c][col] = static_cast<float>(input[idx] * scale);
          }
        }
      }
    }
  }
}

/*
 * @brief softmax - Calculate softmax on CPU
 *
 * @param input   - vector of input data
 * @param output  - output vecotr
 */
inline void DenseBox::softmax(vector<vector<float>> &input, vector<vector<float>> &output) {
  assert(input.size() == 2);

  int channel = input.size();
  int length = input[0].size();

  for (int n = 0; n < length; ++n) {
    float sum = 0.0f;
    for (int i = 0; i < channel; ++i) {
      output[i][n] = exp(input[i][n]);
      sum += output[i][n];
    }
    for (int i = 0; i < channel; ++i) {
      output[i][n] /= sum;
    }
  }
}

/*
 * @brief getOriginalFaceBoxes - Get Original Faceboxes
 *
 * @param outTensor - output Tensor
 * @param tileH - tile height
 * @param tileW - tile width
 * @param tileDim - tile dimension
 * @param pred - prediction vector
 * @param boxes - output facebox vector
 */
void DenseBox::getOriginalFaceBoxes(DPUTensor *outTensor, int tileH, int tileW, int tileDim,
                                    vector<vector<float>> &pred, vector<array<float, 5>> &boxes) {
  float bboutScale = dpuGetTensorScale(outTensor);  // Get bbout layer's scale
  int outputWidth = tileW * tileDim;
  int length_ = dpuGetTensorChannel(outTensor);  // Get bbout layer's channel
  int8_t *bbout = dpuGetTensorAddress(outTensor);
  for (int h = 0, oy = 0; h < tileH; ++h, oy += tileDim) {
    for (int w = 0, ox = 0; w < tileW; ++w, ox += tileDim) {
      for (int ty = 0; ty < tileDim; ++ty) {
        for (int tx = 0; tx < tileDim; ++tx) {
          int os = (oy + ty) * outputWidth + ox + tx;
          if (pred[1][os] > th_conf_) {
            array<float, 5> box;
            int bs = (ty * tileDim + tx) + (h * tileW + w) * length_;
            box[0] = (bbout[bs] * bboutScale + (ox + tx) * 4);
            box[1] = (bbout[bs + tileDim * tileDim] * bboutScale + (oy + ty) * 4);
            box[2] = (bbout[bs + 2 * tileDim * tileDim] * bboutScale + (ox + tx) * 4);
            box[3] = (bbout[bs + 3 * tileDim * tileDim] * bboutScale + (oy + ty) * 4);
            box[4] = (pred[1][os]);
            boxes.emplace_back(box);
          }
        }
      }
    }
  }
}

/*
 * @brief Run - face detection using densebox model
 *
 * @param img - the input image
 *
 * @note the detected face boxes will be directly put on the original input image.
 */
void DenseBox::Run(DPUTask *task, const Mat &img, vector<array<float, 5>>* result) {
  cv::Mat dpuImg;
  _T(cv::resize(img, dpuImg, cv::Size(dpuGetInputTensorWidth(task, input_node_.c_str()), dpuGetInputTensorHeight(task, input_node_.c_str())), 0, 0, cv::INTER_NEAREST));
  // send input image to DPU
  _T(dpuSetInputImage2(task, input_node_.c_str(), dpuImg));

  // process image on DPU
  _T(dpuRunTask(task));

  _T(PostProcess(task, img, result));
}

void DenseBox::PostProcess(DPUTask *task, const Mat &img, vector<array<float, 5>>* result) {
  DPUTensor *convTensor = dpuGetOutputTensor(task, conv_node_.c_str());
  DPUTensor *bboutTensor = dpuGetOutputTensor(task, output_node_.c_str());
  int8_t *convPred = dpuGetTensorAddress(convTensor);

//  int pixelSize = dpuGetTensorSize(convTensor);
  int tileDim = 8;
  int channel = dpuGetTensorChannel(convTensor) / (tileDim * tileDim);
  float pixelScale = dpuGetTensorScale(convTensor);
  int tileH = dpuGetTensorHeight(convTensor);
  int tileW = dpuGetTensorWidth(convTensor);

  int length = tileW * tileH * tileDim * tileDim;
  vector<vector<float>> tileOut(channel);
  for (int i = 0; i < channel; ++i) tileOut[i].resize(length);
  // Reorder the conv layer's output
  tiling(convPred, tileOut, channel, tileH, tileW, tileDim, pixelScale);

  vector<vector<float>> pred(channel);
  for (int i = 0; i < channel; ++i) pred[i].resize(length);
  // Normalization using softmax
  softmax(tileOut, pred);

  // Get original face boxes
  vector<array<float, 5>> boxes;
  getOriginalFaceBoxes(bboutTensor, tileH, tileW, tileDim, pred, boxes);

  // Discard overlapping boxes using NMS
  NMS(boxes, result, th_iou_);
  // Get input node's Tensor width and height
  int kw = dpuGetTensorWidth(dpuGetInputTensor(task, input_node_.c_str()));
  int kh = dpuGetTensorHeight(dpuGetInputTensor(task, input_node_.c_str()));
  float scaleW = ((float)img.cols) / kw;
  float scaleH = ((float)img.rows) / kh;
  for (size_t i = 0; i < result->size(); ++i) {
    (*result)[i][0] *= scaleW;
    (*result)[i][1] *= scaleH;
    (*result)[i][2] *= scaleW;
    (*result)[i][3] *= scaleH;
  }
}
/*
 * @brief Finalize - release resource
 *
 */
void DenseBox::Finalize() {
  __TRACE__
  for (auto task : tasks) dpuDestroyTask(task);
  dpuDestroyKernel(kernel);
}

/*
 * @brief NMS - Discard overlapping boxes using NMS
 *
 * @param box - input box vector
 * @param result - output box vector after discarding overlapping boxes
 * @param threshold - IOU threshold
 */
template <typename T>
void DenseBox::NMS(const vector<array<T, 5>> &box, vector<array<T, 5>> *result, float threshold) {
  size_t count = box.size();
  vector<pair<size_t, T>> order(count);
  for (size_t i = 0; i < count; ++i) {
    order[i].first = i;
    order[i].second = box[i][4];
  }

  // Sort the boxes according score
  sort(order.begin(), order.end(),
       [](const pair<int, T> &ls, const pair<int, T> &rs) { return ls.second > rs.second; });

  // Discard overlapping boxes
  vector<int> keep;
  vector<bool> existBox(count, true);
  T x1, y1, x2, y2, w, h, iarea, jarea, inter, iou;

  for (size_t i = 0; i < count; ++i) {
    size_t idxI = order[i].first;
    if (!existBox[idxI]) continue;

    keep.emplace_back(idxI);
    for (size_t j = i + 1; j < count; ++j) {
      size_t idxJ = order[j].first;
      if (!existBox[idxJ]) continue;
      x1 = max(box[idxI][0], box[idxJ][0]);
      y1 = max(box[idxI][1], box[idxJ][1]);
      x2 = min(box[idxI][2], box[idxJ][2]);
      y2 = min(box[idxI][3], box[idxJ][3]);
      w = max(T(0.0), x2 - x1 + 1);
      h = max(T(0.0), y2 - y1 + 1);
      iarea = (box[idxI][2] - box[idxI][0] + 1) * (box[idxI][3] - box[idxI][1] + 1);
      jarea = (box[idxJ][2] - box[idxJ][0] + 1) * (box[idxJ][3] - box[idxJ][1] + 1);
      inter = w * h;
      iou = inter / (iarea + jarea - inter);
      if (iou >= threshold) existBox[idxJ] = false;
    }
  }

  result->reserve(keep.size());
  for (size_t i = 0; i < keep.size(); ++i) {
    result->emplace_back(box[keep[i]]);
  }
}

}  // end of namespace deephi
